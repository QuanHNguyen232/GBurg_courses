{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":65740800},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.2"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1598361950560,"exec_count":1,"id":"815ceb","input":"print(5, 'divided by', 3, 'is', 5 // 3, 'remainder', 5 % 3)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"5 divided by 3 is 1 remainder 2\n"}},"pos":3,"start":1598361950551,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950581,"exec_count":2,"id":"54a3df","input":"n = 42\noriginal = n\nprint('Original number:', original)\nn *= 2  # Double it.\nn += 9  # Add 9.\nn -= 3  # Subtract 3.\nn /= 2  # Divide by 2.\nn -= original  # Subtract your original number.\n# Your answer should be 3.\nprint(\"Your answer should be 3:\", n)\n\n# Note that the division operation causes n to become a float, even though the result will be an int if n is originally an int.\n# We can convert n back to an int as follows:\nn = int(n)\nprint(\"Your answer should be 3:\", n)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Original number: 42\nYour answer should be 3: 3.0\nYour answer should be 3: 3\n"}},"pos":5,"start":1598361950572,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950604,"exec_count":3,"id":"1e7ad1","input":"a = 4\nb = 2\nprint(a != b)  # not equal to\nprint(a < b)  # less than\nprint(a <= b)  # less than or equal to\nprint(a == b)  # equal to\nprint(a >= b)  # greater than or equal to\nprint(a > b)  # greater than","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"True\nFalse\nFalse\nFalse\nTrue\nTrue\n"}},"pos":7,"start":1598361950589,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950625,"exec_count":4,"id":"9ff65e","input":"b1 = True\nb2 = False\nprint(b1 and b2)\nprint(b1 or b2)\nprint(not b1)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"False\nTrue\nFalse\n"}},"pos":9,"scrolled":true,"start":1598361950611,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950649,"exec_count":5,"id":"a272ca","input":"list1 = ['a', 'b', 'c']  # Variable list1 refers to a Python list object as we'll see below under Python Data Structures.\nlist2 = ['a', 'b', 'c']  # Variable list2 refers to a different list in memory that contains the same values.\nprint(list1 == list2)  # The two lists refered to represent the same values.\nprint(list1 is list2)  # However, they are not the same objects in memory.\nprint(list1 is not list2)\n\n# We can make list2 refer to list1's value with assignment.  Then the two variables refer to the same object in memory:\nlist2 = list1  # Variable list2 now refers to the object that list1 refers to.\nprint(list1 is list2)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"True\nFalse\nTrue\nTrue\n"}},"pos":11,"start":1598361950634,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950678,"exec_count":6,"id":"8e75e2","input":"print('b' in list1)\nprint('d' in list1)\nprint('d' not in list1)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"True\nFalse\nTrue\n"}},"pos":13,"start":1598361950656,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950699,"exec_count":7,"id":"41dbc4","input":"print(9 ** 100)\nprint(-3 ** 191)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"265613988875874769338781322035779626829233452653394495974574961739092490901302182994384699044001\n-13494588674281093803728157396523884917402502294030101914066705367021922008906273586058258347\n"}},"pos":16,"scrolled":true,"start":1598361950685,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950721,"exec_count":8,"id":"f8d0cd","input":"print(9.0 ** 100)\nprint(-3.0 ** 191)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"2.6561398887587478e+95\n-1.3494588674281094e+91\n"}},"pos":18,"scrolled":true,"start":1598361950705,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950767,"exec_count":9,"id":"72afe0","input":"print(\"{0:f}\".format(9.0 ** 100))  # Don't concern yourself with learning the format() function yet.\nprint(\"{0:f}\".format(-3.0 ** 191))  # These are here for illustration.","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"265613988875874780598610418785575466612106726486464451918226939374088579537852722003778744614912.000000\n-13494588674281094349589685078527246043109139047383585442215822735858758461598494549537193984.000000\n"}},"pos":20,"start":1598361950728,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950800,"exec_count":10,"id":"6bf0f7","input":"print(.1 + .2 == .3)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"False\n"}},"pos":22,"scrolled":true,"start":1598361950793,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950845,"exec_count":11,"id":"d87e21","input":"x = .1 + .2\ny = .3\nprint(x == y)  # float equality test\n\nfrom math import isclose\nprint(isclose(x, y))\nprint(isclose(10000000000000000000000.0, 10000000000000000000001.0))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"False\nTrue\nTrue\n"}},"pos":24,"start":1598361950830,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950858,"exec_count":12,"id":"cada42","input":"print(float(42))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"42.0\n"}},"pos":26,"start":1598361950853,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950893,"exec_count":13,"id":"b5fffa","input":"print(int(2.9))\nprint(int(-2.9))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"2\n-2\n"}},"pos":28,"scrolled":true,"start":1598361950864,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950929,"exec_count":14,"id":"302d3f","input":"import cmath\nc = cmath.sqrt(9) + cmath.sqrt(-2)  # Note: normal math.sqrt will raise a ValueError with negative numbers\nprint(c)\nprint(type(c))\nprint(c.real)  # real part\nprint(c.imag)  # imaginary part\nc2 = complex(7, -1)  # creating a complex number directly\nprint(c + c2)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"(3+1.4142135623730951j)"},"1":{"name":"stdout","text":"\n<class 'complex'>\n3.0\n1.4142135623730951\n(10+0.41421356237309515j)\n"}},"pos":30,"start":1598361950911,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361950969,"exec_count":15,"id":"931d2d","input":"s = 'spam '  # double-quotes may be used too.  This is equivalent to s = \"spam\".\nprint(s)\ns = s.capitalize()\nprint(s)  # s is now capitalized\nprint(s[0])  # the first character of s (think \"0 forward from the first letter\")\nprint(s[1])  # the second character of s (think \"1 forward from the first letter\")\nprint(3*s)  # \"multiplying\" strings creates a new string that has that many copies in sequence\nbb = 'Baked Beans'\nprint(len(bb))  # the length of the string, i.e. the number of characters\nmenu_item = 3*s + bb + ' and ' + s  # string concatenation (+) creates a new string by combining strings in sequence\nprint(menu_item)\nprint(menu_item.upper())  # to uppercase\nprint(menu_item.lower())  # to lowercase\n\n# We'll see other useful string operators as we go forward.\nprint(', '.join(['I like strings', 'concatenation', 'and Oxford commas.']))  # joining strings with a separator string\nprint('Testing 1 2 3'.split(' '))  # splitting a string at given separator string occurrences","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"spam \nSpam \nS\np\nSpam Spam Spam \n11\nSpam Spam Spam Baked Beans and Spam \nSPAM SPAM SPAM BAKED BEANS AND SPAM \nspam spam spam baked beans and spam \nI like strings, concatenation, and Oxford commas.\n['Testing', '1', '2', '3']\n"}},"pos":32,"scrolled":true,"start":1598361950940,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951017,"exec_count":16,"id":"0e5caf","input":"value_returned_by_print = print(\"The print function doesn't return a value.\")\nprint(value_returned_by_print)\nprint(type(value_returned_by_print))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"The print function doesn't return a value.\nNone\n"},"1":{"name":"stdout","text":"<class 'NoneType'>\n"}},"pos":35,"start":1598361950975,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951056,"exec_count":17,"id":"c63288","input":"print(bool(0))\nprint(bool(0.0))\nprint(bool([]))\nprint(bool(print(\"(This space intentionally left non-False.)\")))\nprint(bool(complex(0, 0)))\nprint(bool(()))\nprint(bool({}))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"False\nFalse\nFalse\n(This space intentionally left non-False.)\nFalse\nFalse\nFalse\nFalse\n"}},"pos":37,"start":1598361951029,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951313,"exec_count":19,"id":"9ee366","input":"l = list('testing')\nprint(l)\nprint(''.join(l))  # We can convert it back to a string using the join function and an empty string separator.\nprint(len(l))  # Function len() returns the length of a list.\nprint(l[0])  # Note that we have 0-based indexing just as when referring to characters in a string.\nprint(l[1])\nprint(l[-1])  # Negative indices work backwards from after the end of the string.\nprint(l[-2])\nl2 = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]  # Lists can be of any type.\nprint(l2)\nl3 = [42, 3.14, 'a', True, None, complex(2, 3)]  # Lists can contain mixed types.\nprint(l3)\nprint(l[0:4])  # Slicing allows us to get sublists (without modifying the original) using the first index included and the first index _not_ included.\nprint(l[2:7])\nprint(l[:4])  # When a slice index is omitted, the extreme value (beginning or end) is assumed.\nprint(l[2:])\nprint(l[:]) \n# Try slicing to get the sublist ['t', 'i', 'n'].","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"['t', 'e', 's', 't', 'i', 'n', 'g']\ntesting\n7\nt\ne\ng\nn\n[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]\n[42, 3.14, 'a', True, None, (2+3j)]\n['t', 'e', 's', 't']\n['s', 't', 'i', 'n', 'g']\n['t', 'e', 's', 't']\n['s', 't', 'i', 'n', 'g']\n['t', 'e', 's', 't', 'i', 'n', 'g']\n"}},"pos":43,"start":1598361951304,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951353,"exec_count":20,"id":"dd5c2f","input":"l[0] = 'r'  # change the first element to 'r'\nprint(l)\nl.insert(0, 'w')  # insert 'w' in the list before the first element\nl.insert(-3, 'l')  # insert 'l' in the list before the third-from-last\nprint(l)\nprint(''.join(l))","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"['r', 'e', 's', 't', 'i', 'n', 'g']\n['w', 'r', 'e', 's', 't', 'l', 'i', 'n', 'g']\nwrestling\n"}},"pos":45,"start":1598361951323,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951403,"exec_count":21,"id":"e6d60e","input":"print(l2 + l3)\nprint(['tro'] + 10 * ['lo'])","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 42, 3.14, 'a', True, None, (2+3j)]\n['tro', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo', 'lo']\n"}},"pos":47,"start":1598361951362,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951430,"exec_count":22,"id":"318bc3","input":"print(l2)\nl2.append(42)\nprint(l2)\nl2.sort()\nprint(l2)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]\n[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 42]\n[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 8, 9, 42]\n"}},"pos":49,"start":1598361951413,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951467,"exec_count":23,"id":"84262a","input":"t = (42, 3.14, 'a')\nprint(t)\nprint(len(t))  # As with lists, we can use len() to find the length.\nprint(t[1])  # As with lists, we can access with 0-based indexing.\n# t[1] = 'new value'  However, unlike lists, this would cause an error because we cannot change tuples.\n\n# Some functions return multiple values.  When they do, they return a tuple:\nx = 0.1875\nprint(x)\nprint(type(x))\nnum_den = x.as_integer_ratio()\nprint(num_den)\nprint(type(num_den))\n\n# Parallel assignment can be used to assign tuple return values to separate variables:\n(numerator, denominator) = x.as_integer_ratio()\nprint(numerator)\nprint(denominator)\n","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"(42, 3.14, 'a')\n3\n3.14\n0.1875\n<class 'float'>\n(3, 16)\n<class 'tuple'>\n3\n16\n"}},"pos":52,"start":1598361951437,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951517,"exec_count":24,"id":"320f0d","input":"leet_dict = {}  # Dictionaries are surrounded by curly braces.  Here we initialize an empty dictionary.\nleet_dict['1337'] = 'leet/elite'\nleet_dict['haxor'] = 'hacker'\nleet_dict['n00b'] = 'newbie'\nleet_dict['pwn3d'] = 'dominated'\nprint(leet_dict)  # Note the printed syntax.  That syntax may also be used to build a dictionary directly:\nd = {'1337':'leet/elite', 'haxor':'hacker', 'n00b':'newbie', 'pwn3d':'dominated'}  # Each entry is a comma-separated key:value pair.\nprint(d == leet_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'1337': 'leet/elite', 'haxor': 'hacker', 'n00b': 'newbie', 'pwn3d': 'dominated'}\nTrue\n"}},"pos":54,"start":1598361951477,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951552,"exec_count":25,"id":"f0ffce","input":"key = 'n00b'\nvalue = d[key]\nprint(key, 'means', value)\nprint(len(d))  # len() gives us the size of the dictionary, i.e. the number of key-value pairs.","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"n00b means newbie\n4\n"}},"pos":56,"start":1598361951526,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951580,"exec_count":26,"id":"6ede00","input":"set1 = {1, 2, 2}\nprint(set1)  # Note that the redundant 2 has been removed.\nset2 = {3, 2}\nprint(set2)  # Note that the printed order is different than in the definition.  Python keeps its own order.\nprint(set1.union(set2))  # Set union - values in both set1 and set2\nprint(set1, set2) # Note that set operators like union do not change sets, but build a new set.\nprint(set1.intersection(set2))  # Set intersection - values in set1 or set2\nprint(set1.difference(set2))  # Set difference - values in set1 that are not in set2 (subtracting elements of set2)\nprint(set1.symmetric_difference(set2))  # Set symmetric difference - values unique to sets, i.e. the union subtracting the intersection","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{1, 2}\n{2, 3}\n{1, 2, 3}\n{1, 2} {2, 3}\n{2}\n{1}\n{1, 3}\n"}},"pos":58,"start":1598361951560,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951608,"exec_count":27,"id":"9862ab","input":"total_cents = 123\n# Print the equivalence of the total_cents variable with the number of whole dollars and remaining cents:","kernel":"python3","no_halt":true,"pos":60,"start":1598361951586,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951662,"exec_count":29,"id":"1695f7","input":"w = []\nw.append('i')\nprint(w)\n","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"['i']\n"}},"pos":66,"start":1598361951647,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951695,"exec_count":30,"id":"75c7bf","input":"beats = {}\nbeats['rock'] = 'scissors'\nbeats['scissors'] = 'paper'\nbeats['paper'] = 'rock'\nmy_play = 'scissors'\nprint('My play:', my_play)\nprint('You lose if you play:', beats[my_play]) ","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"My play: scissors\nYou lose if you play: paper\n"}},"pos":68,"start":1598361951671,"state":"done","type":"cell"}
{"cell_type":"code","end":1598361951732,"exec_count":31,"id":"022eb8","input":"is_beaten_by={}","kernel":"python3","no_halt":true,"pos":70,"start":1598361951703,"state":"done","type":"cell"}
{"cell_type":"code","end":1598362012055,"exec_count":33,"id":"b15c94","input":"import math\nprint(bool(42))\nprint(bool(3.14))\nprint(bool(['a', 'b', 'c']))\nprint(bool(math.sqrt(2)))\nprint(bool(cmath.sqrt(-2)))\nprint(bool(('tuple','values')))\nprint(bool({'one':1, 'two':2, 'three':3}))\nprint(bool({'set', 'elements'}))","kernel":"python3","output":{"0":{"name":"stdout","text":"True\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n"}},"pos":39,"start":1598362012040,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":28,"id":"fe6e34","input":"w = ['a', 'b', 'a', 'n', 'd', 'o', 'n']\nprint(w[0:1])  # ['a']\nprint(w[1:4])  # ['b', 'a', 'n']\n# ['b', 'a', 'n', 'd']\n# ['a', 'n']\n# ['a', 'n', 'd']\n# ['d', 'o']\n# ['d', 'o', 'n']\n# ['o', 'n']","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"['a']\n['b', 'a', 'n']\n"}},"pos":64,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0477f3","input":"Converting from an int to a float is straightforward:","pos":25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"06c1dd","input":"Compare these latest values with those of our integer computation, and you'll see that the results are different.  (The int computations are correct.)\n\nRead the VanderPlas assigned reading to understand better why the following occurs:","pos":21,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0e7d0c","input":"# Homework\n\n(1) In the code cell below, use integer division operators of floor division (//) and modulus (%) to take the \"total_cents\" variable below and to compute the latter two values and print \"# cents is the same as # dollars and # cents.\", e.g. \"123 cents is the same as 1 dollars and 23 cents.\"  Then, change the 123 to 1995 and check that your printed result changes appropriately.","pos":59,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"13c040","input":"You'll note that we create mappings with a syntax similar to list element assignment.  We look up values from keys with a similar syntax:","pos":55,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1ac1bd","input":"## NoneType\n\nPython functions can return values (like ```sqrt(2)```).  However, they needn't.  In fact, Python functions return a special None value by default:","pos":34,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"211582","input":"So whereas strings are immutable (unchangeable), one can convert a string to a list, freely modify the mutable list, and reform a new changed string.\n\nLists can also be concatenated and multiplied:","pos":46,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"25ec18","input":"## More Arithmetic Operators\n\nIn addition to the addition (+), subtraction (-), multiplication (\\*), division (/), and exponentiation (\\*\\*) operators you've already seen, we see that there are also new operators (// and %) for integer division. (Look at the Markdown for this cell to see how I use the \"\\\\\", i.e. the escape character, to have \"\\*\" interpreted literally instead of its Markdown meaning.)\n\nFloor division (//) and modulus (%) are not complicated; it's just that we typically haven't seen them since early grade school.  Remember when we said \"5 divided by 3 is 1 remainder 2\", or perhaps you wrote the notation \"5 $\\div$ 3 = 1R2\".  That's exactly what's going on in the next Python code cell:","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2bdec0","input":"Now you define the reverse mapping dictionary \"is_beaten_by\" on the next single line (using comma-separated key:value pairs).\nThen, like the last line of the previous code cell, use your is_beaten_by dictionary to recommend the winning play ('You win if you play: \\<play inserted here\\>').","pos":69,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2dc45d","input":"## Boolean Operators\n\nThe ```True``` and ```False``` values you see above are called \"Boolean\" values, named for logician George Boole.  Boolean values are both the inputs and outputs for Boolean operators ```and```, ```or```, and ```not```:","pos":8,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2dceaa","input":"However, consider carefully what happens with a float converted to an int:","pos":27,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"30d4d2","input":"# Python Operators","pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"37fb14","input":"# Python Values","pos":14,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"3cc63b","input":"Anything other than these special values that convert to ```False``` are not ```False``` and are thus ```True```:","pos":38,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"40db9d","input":"Because lists are mutable (changeable), there are a variety of ways we can modify them:","pos":44,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"48230d","input":"## Tuples\n\nTuples are like immutable lists.  Syntactically, they appear in parenthesis rather than in square brackets:","pos":51,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"536507","input":"Python ```float```s, however, are fixed precision, so watch what happens to these computations:","pos":17,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"61abcb","input":"There are _many_ more things we can do with strings.  If you'd like to learn more, another good reference is:\n* Allen B. Downey.  [Think Python 2e](https://greenteapress.com/wp/think-python-2e/):\n  * [Chapter 8  Strings](http://greenteapress.com/thinkpython2/html/thinkpython2009.html) _This isn't assigned reading, but know that it's there for you._","pos":33,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"70d881","input":"## Assignment Operators\n\nWe often want to perform a simple arithmetic operation on a variable, e.g. incrementing it, doubling it, squaring it, etc.\nIn Games Magazine, Richard W. O'Donnell shared some [simple number tricks](https://www.pleacher.com/mp/puzzles/tricks/nums.html) that can help illustrate this in a fun way.  For example: \n\n> The Number 3 Trick\n> - Take a number.\n> - Double it.\n> - Add 9.\n> - Subtract 3.\n> - Divide by 2.\n> - Subtract your original number.\n> - Your answer should be 3.\n\nHere is the Python to perform these operations:","pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"75f54d","input":"## Comparison Operators\n\nMost comparison operators are straightforward.  Equality (== \"equals\") and inequality (!= \"not equals\") are what take some getting used to at first.  Remember that \"!\" often means \"not\" in programming languages.  The reason we need two equal signs is that a single equals means variable assignment, taking what is on the right and assigning its reference to the named variable on the left.  One other helpful tip: If you're trying to remember whether it's \">=\" or \"=>\", remember that in English we tend to say the phrase \"greater than or equal to\".  Follow the natural phrasing and you'll have no problem getting it right.\n\nEach comparison operator is takes two values on the left and the right, and evaluates to a single True/False Boolean (bool) value depending on whether or not the relationship is true.  For example:","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"76f6b9","input":"## Booleans\n\nWe've already seen Boolean values of type ```bool``` in Python.  What we haven't seen is an important way that Python allows values of different types to represent False when converted to ```bool``` type:","pos":36,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7ab7bc","input":"## Sets\n\nSets have curly-brace syntax like dictionaries, but support the usual mathematical set operations.  Sets are unordered and each element is unique.","pos":57,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"909035","input":"## Dictionaries\n\nDictionaries are mappings (i.e. associations) from input values, called \"keys\", to output values, called simply \"values\".  Think of them as lookup tables.\nEach key maps to one value.  Different keys can map to a equal value, i.e. outputs are not necessarily unique.","pos":53,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9571d5","input":"(end of homework)","pos":71,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9ad8dc","input":"The important takeaway here is that one cannot treat float arithmetic as precise.  We often need to test for _approximate equality_ (i.e. the absolute difference between two values is small) or _relative approximate equality_ (i.e. the absolute difference divided by the magnitude of the larger value is small).  As of Python 3.5, there is a math library function ```isclose``` that tests whether two values are relatively approximately equal:\n","pos":23,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9f774f","input":"This is what is known as _integer truncation_.  No rounding occurs; fractional value are lost.\n\n## Complex Numbers\n\nComplex number occur when we take the square root of a negative number.  Each complex number has a _real_ part and an _imaginary_ part.  The complex number is the sum of the real part plus the real imaginary part times $i = \\sqrt{-1}$.  In Python complex notation, ```j``` is used instead of standard mathematics constant $i$.","pos":29,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a670ae","input":"At first, one might think that the two results are the same precision with \"exponential\" or \"scientific\" notation results rounded to $2.6561398887587478\\times10^{95}$ and $-1.3494588674281094\\times10^{91}$.  But printing the values to more digits with print formatting reveals that we lose precision with floating-point computations:","pos":19,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a7fa15","input":"(3) Create a Code cell immediately below where you do the following:\n* Assign x to be 0.001.\n* Assign y to be the square root of x.\n* Assign x2 to be y times y.\n* Print whether or not x and x2 have the same numeric value.\n* Print whether or not x and x2 values are relatively approximately equal.\n* Print whether or not x and x2 are the same identical object in memory.\n","pos":62,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ae0930","input":"## Lists\n\nLists are mutable (changeable) sequences of values.  The values are often referred to as _items_ or _elements_.  Here, we will use list conversion of a string to get a list of its characters:","pos":42,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"af6702","input":"There are many other things we can do with lists, but these are some of the basics.","pos":50,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"b6e617","input":"(2) Create a code cell immediately below where you demonstrate [The Number 4 Trick](https://www.pleacher.com/mp/puzzles/tricks/nums.html) in the way that The Number 3 Trick is demonstrated above, but only confirming the integer result once (i.e. without the float result line).","pos":61,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ba2bff","input":"This will prove useful when we get to programming decisions and filtering results.","pos":40,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c71a13","input":"## Identity Operators\n\nRecall that Python values are _objects_.  Our \"==\" relational operator asks the question whether or not two objects represent the same value.  We can also test whether or not two objects are the _same object in memory_:","pos":10,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"cc73f3","input":"(5) Starting with the empty list below, follow each of these steps.  The first is done for you.\n* Append an 'i' and print the list.\n* Append an 'n' and print the list.\n* Insert an 's' before the 'i' and print the list.\n* Append a 'g' and print the list.\n* Insert a 't' before the 'i' and print the list.\n* Insert an 'r' before the 'i' and print the list.\n* Insert an 'a' before the 'r' and print the list.\n* Insert a 't' before the 'i' and print the list.  Use a negative index.\n\nThe correct printed output of each step should spell a word.","pos":65,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"cee976","input":"(6) Familiarize yourself with the game of [Rock-Paper-Scissors](https://en.wikipedia.org/wiki/Rock_paper_scissors).  Below, I build an example \"beats\" dictionary. and demonstrate it.","pos":67,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d17a86","input":"(4) In the code cell below, use slicing before each comment to print the ```letters``` sublist indicated in the comment.  The first two are done for you.  For the final two, use negative indexing.  (More fun example exercises can be found at [Puzzling StackExchange](https://puzzling.stackexchange.com/questions/53277/english-word-with-most-valid-substrings).)  ","pos":63,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"dc621d","input":"# Python Data Structures","pos":41,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e6ce5f","input":"# Python Operators, Values, and Data Structures\n\nLearning Objectives:\n* Students will learn basics of Python operators: arithmetic, augmented assignment, comparison, Boolean, identity, and membership.\n* Students will learn basics of Python simple types: int, float, complex, bool, str, NoneType.\n* Students will learn basics of Python lists, tuples, dictionaries, and sets.\n\nReadings before class:\n\n* Jake VanderPlas.  [A Whirlwind Tour of Python](https://github.com/jakevdp/WhirlwindTourOfPython) sections:\n  * [04 - Basic Python Semantics: Operators](https://github.com/jakevdp/WhirlwindTourOfPython/blob/master/04-Semantics-Operators.ipynb) _Be thorough otherwise, but feel free to **skip the Bitwise Operators section**.  The other operators are more relevant to our work.  Bitwise operators are commonly used to pack and unpack \"bitpacked\" data, i.e. data that is encoded as compactly as possible in 0's and 1's.  For the curious, here is [an example of bitpacking](https://www.codementor.io/@christkv/bit-packing-or-how-to-love-and-or-or-xor-vpmz3f1dm)._\n  * [05 - Built-In Types: Simple Values](https://github.com/jakevdp/WhirlwindTourOfPython/blob/master/05-Built-in-Scalar-Types.ipynb) _In this section, we extend beyond our initial exposure to int, float, and str to include complex, bool, and NoneType.  We will use complex rarely if at all, but bool and NoneType are also common in Python programming._\n  * [06 - Built-In Data Structures](https://github.com/jakevdp/WhirlwindTourOfPython/blob/master/06-Built-in-Data-Structures.ipynb)  _In this section, we begin to explore compound types, types that structure our simple type data together, hence the name \"data structures\".  Start playing with these and build your comfort level with their operations, as we will use these a lot in Python programming._\n  * **Note:** Both VanderPlas texts are available within CoCalc if you'd like to interact with its Jupyter notebooks. Select \"Files\" (the one with the folder icon, not the \"File\" menu) and click the \"Library\" button.  A search for \"Whirlwind\" and \"Vanderplas\" should lead you to each.  These can be downloaded as copies within CoCalc.\n* Allen B. Downey.  [Think Python 2e](https://greenteapress.com/wp/think-python-2e/):\n  * **Note:** Don't expect to become a master of these without a lot of practice.  Thing of these readings as giving you initial exposure to these tools for structuring and accessing data.  It's most important that you know what's here so that you can refer to the syntactic forms when you need to.  For example, I often forgot how to add an item to the end of a Python list at first, and needed to look it up and practice it before the append() function became a habit.  You'll need to look things up too, so read these to form an index of _where_ to find how to do things.  You don't need to memorize it all.  Know where to look it up and trust that _you'll remember what you use frequently_.\n  * [Chapter 10  Lists](http://greenteapress.com/thinkpython2/html/thinkpython2011.html) _You can skip 10.7 \"Map, filter and reduce\" and 10.12 \"List arguments\".  These are important topics, but rely on prior chapter content not yet covered._\n  * [Chapter 11  Dictionaries, Section 11.1 only](http://greenteapress.com/thinkpython2/html/thinkpython2012.html) _Dictionaries associate values with other values for easy access._\n  * [Chapter 12  Tuples, Sections 12.1-12.2 only](http://greenteapress.com/thinkpython2/html/thinkpython2013.html) _Tuples are immutable (unchangeable) lists of values._\n\nActivities before class:\n* Read below up to (but not including) the section marked Homework.  You are encouraged to add code blocks and play with the forms to gain understanding and comfort with them.\n\nHomework after class:\n* Complete the section labeled \"Homework\" below before the next class when it will be collected.","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e8a1fc","input":"We can append a single item to the end of a list.  We can also sort lists in place.","pos":48,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ecef19","input":"## Membership operators\n\nFor lists, sets, and such, we can easily ask whether or not a value is contained in the data structure:","pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f1fcc0","input":"## Strings\n\nA string (```str```) is a string or sequence of characters.  There are many operators for the ```str``` type. Here we demonstrate a few:","pos":31,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f40a20","input":"## Integers and Floating-Point Numbers\n\nWe've already see integers (type int) and floating-point numbers (type float).  Here are some additional important details:\n\nPython ```int```s are not fixed precision.  There is not a limit to the number of bits to represent an integer, so we can represent large numbers that in other languages with fixed precision integers would _overflow/underflow_, that is exceed above/below the greatest/least representable integer, respectively.","pos":15,"state":"done","type":"cell"}
{"id":0,"time":1598471270432,"type":"user"}
{"last_load":1597979313709,"type":"file"}