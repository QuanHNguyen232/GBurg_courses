import java.util.ArrayList;
import java.util.Random;


public class UniformRandomGameNode extends GameNode {
	
	public static Random random = new Random();
	public static int nodeCount, expandCount, utilityCount; // counts for search statistics
	int numChildren; // node branching factor
	int depthRemaining; // tree depthRemaining
	long seed; // random number seed
	
	/**
	 * @param numChildren node branching factor
	 * @param depthRemaining depth remaining in game tree
	 * @param seed random number seed
	 */
	public UniformRandomGameNode(int numChildren, int depthRemaining, long seed) {
		this.numChildren = numChildren;
		this.depthRemaining = depthRemaining;
		this.seed = seed;
		player = MAX;
		nodeCount++;
	}

	/**
	 * @param player current player (GameNode.MAX or GameNode.MIN), alternating from parent to child
	 * @param numChildren node branching factor
	 * @param depthRemaining depth remaining in game tree
	 * @param seed random number seed
	 */
	public UniformRandomGameNode(int player, int numChildren, int depthRemaining, long seed) {
		this(numChildren, depthRemaining, seed);
		this.player = player;
	}
	
	public ArrayList<GameNode> expand() { // create the given number of random children nodes, each with successive seeds that follow the parent seed, decrementing depthRemaining
		random.setSeed(seed);
		ArrayList<GameNode> children = new ArrayList<GameNode>();
		if (depthRemaining > 0)
			for (int i = 0; i < numChildren; i++)
				children.add(new UniformRandomGameNode(player == MAX ? MIN : MAX, numChildren, depthRemaining - 1, random.nextLong()));
		expandCount++;
		return children;
	}

	@Override
	public boolean gameOver() { // the random game ends at the terminal depth
		return depthRemaining == 0;
	}

	@Override
	public double utility() { // the utility of a leaf node is the uniform random double generated by the node seed
		random.setSeed(seed);
		utilityCount++;
		return random.nextDouble();
	}
	
	static public void resetCounts() { // reset counts used for search statistics
		nodeCount = expandCount = utilityCount = 0;
	}
	
	public static void main(String[] args) {
		/*
		 * nodeCount: +1 when a node is created
		 * expandCount: +1 when node's expand() is called
		 * utilityCount: +1 when game over or depth limit reached
		 */
		
		int factor = 2;
		int depth = 4;
		
		UniformRandomGameNode node = new UniformRandomGameNode(factor, depth, 4242L);
				
		AlphaBetaSearcher searcher1 = new AlphaBetaSearcher(depth);
		double res1 = searcher1.eval(node);
		double utilityCountAlphaBeta = UniformRandomGameNode.utilityCount;
		System.out.println("res1= " + res1
				+ "\t nodeCount= " + UniformRandomGameNode.nodeCount
				+ "\t expandCount= " + UniformRandomGameNode.expandCount
				+ "\t utilityCount= " + UniformRandomGameNode.utilityCount);
		
		UniformRandomGameNode.resetCounts();
		
		MinimaxSearcher searcher2 = new MinimaxSearcher(depth);
		double res2 = searcher2.eval(node);
		double utilityCountMinimax = UniformRandomGameNode.utilityCount;
		System.out.println("res2= " + res2
				+ "\t nodeCount= " + UniformRandomGameNode.nodeCount
				+ "\t expandCount= " + UniformRandomGameNode.expandCount
				+ "\t utilityCount= " + UniformRandomGameNode.utilityCount);
		
		System.out.println("ratio = " + (utilityCountAlphaBeta / utilityCountMinimax));
	}
}
